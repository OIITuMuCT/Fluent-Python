# Пример 2.22. Простые операции со строками и столбцами из модуля numpy.ndarray
import numpy as np
a = np.arange(12)
print(a)
print(type(a))
a.shape = 3, 4
print(a)
print(a[2])
print(a[2, 1])
print(a[:, 1])
a.transpose()
print(a)

# 1 Импортировать NumPy, предварительно установив (этот пакет не входит
# в стандартную библиотеку Python).
# 2 Построить и распечатать массив numpy.ndarray, содержащий целые числа от 0 до 11.
# 3 Распечатать размерности массива: это одномерный массив с 12 элементами.
# 4 Изменить форму массива, добавив еще одно измерение, затем распечатать результат.
# 5 Получить строку с индексом 2.
# 6 Получить элемент с индексами 2, 1.
# 7 Получить столбец с индексом 1.
# 8 Создать новый массив, транспонировав исходный (т. е. переставив местами строки и столбцы).

>>> import numpy
>>> floats = numpy.loadtxt('floats-10M-lines.txt') 
>>> floats[-3:] 
array([ 3016362.69195522, 535281.10514262, 4566560.44373946])
>>> floats *= .5 
>>> floats[-3:]
array([ 1508181.34597761, 267640.55257131, 2283280.22186973])
>>> from time import perf_counter as pc 
>>> t0 = pc(); floats /= 3; pc() - t0 
0.03690556302899495
>>> numpy.save('floats-10M', floats) 
>>> floats2 = numpy.load('floats-10M.npy', 'r+') 
>>> floats2 *= 6
>>> floats2[-3:] 
memmap([ 301636

# 1 Загрузить 10 миллионов чисел с плавающей точкой из текстового файла.
# 2 С помощью нотации получения среза распечатать последние три числа.
# 3 Умножить каждый элемент массива floats на 0.5 и снова распечатать по-
# следние три элемента.
# 4 Импортировать таймер высокого разрешения (включен в стандартную
# биб­лиотеку начиная с версии Python 3.3).
# 5 Разделить каждый элемент на 3; для 10 миллионов чисел с плавающей точ-
# кой это заняло менее 40 миллисекунд.
# 6 Сохранить массив в двоичном файле с расширением .npy.
# 7 Загрузить данные в виде спроецированного на память файла в другой мас-
# сив; это позволяет эффективно обрабатывать срезы массива, хотя он и не
# находится целиком в памяти.
# 8 Умножить все элементы на 6 и распечатать последние три.